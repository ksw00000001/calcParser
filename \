type Variables = String

data ParseTree
   = Identifier Variables
   | Abstraction (Variables, ParseTree) 
   | Application (ParseTree, ParseTree)
      deriving (Show,Read,Eq)

type ErrorMessage = String

findMostLeftTerm :: [String] -> Either ErrorMessage ([String],[String])
-- ex) findMostLeftTerm (words "( \\a. ( b c ) d ) e" == Right (["\\a.","(","b","c",")","d"],["e"])
findMostLeftTerm (")":_)  = Left "bracket unmatched - somewhere starts with )"
findMostLeftTerm ("(":xs) = searchPairBracket xs 1
findMostLeftTerm ss@(('\\':_):_)  = Right (ss,[])
findMostLeftTerm   (x:xs) = Right (x:[],xs)
findMostLeftTerm x        = Right (x,[])

searchPairBracket :: [String] -> Integer -> Either ErrorMessage ([String], [String])
-- ex) searchPairBracket (words " \\a. ( a a ) a ) a" ) == Right (["\\a.","(","a","a",")","a"],[,"a"]) 
searchPairBracket ss 0 = Right ([],ss)
searchPairBracket [] _ = Left "bracket unmatched - too many ("
searchPairBracket ("(":xs) n = do
   (fp,bp) <- searchPairBracket xs (n+1)
   Right (("(":fp),bp)
searchPairBracket (")":xs) n = do
   (fp,bp) <- searchPairBracket xs (n-1)
   if n-1 == 0
   then do
      Right (fp,bp)
   else do
      Right ((")":fp),bp)
searchPairBracket   (x:xs) n = do
   (fp,bp) <- searchPairBracket xs n
   Right ((x:fp),bp)

findMostRightPart :: [String] -> Either ErrorMessage ([String],[String])
findMostRightPart ss = do
   (fp,bp) <- findMostLeftTerm ss
   if bp == []
      then do
         Right ([],fp)
      else do
         (lp,rp) <- findMostRightPart bp
         Right ((fp ++ lp), rp)

deconposeToWords :: String -> [String]
deconposeToWords s = words (filter (/=',') s)

parsingIntoTree :: [String] -> Either ErrorMessage ParseTree
parsingIntoTree ss = 
   case ss of
      [] -> Left "empty formula"
      (('\\':xs):[]) -> Left "A lambda part is not forming an abstruction"
      (x:[])         -> Right (Identifier x) 
      (('\\':xs):ys) -> do
         yys <- parsingIntoTree ys
         Right (Abstraction (xs, yys))
      _              -> do
         (lp,rp) <- findMostRightPart ss
         rpPurse <- parsingIntoTree rp
         lpPurse <- parsingIntoTree lp
         Right (Application (lpPurse, rpPurse))
      

--alphaConversion :: 
